# Copyright:: Copyright 2012 Trimble Navigation Ltd.
# License:: Apache License version 2.0
# Original Author:: Scott Lininger 
# Author: Simone Nicolo 
#
# Tests the SketchUp Ruby API ComponentInstance object.
#
# This file was originally generated by ourdoc.rb, an internal tool we developed
# specifically for outputting support files (documentation, unit tests, etc.)
# from the standard, doxygen-style c++ comments that are embedded into the
# Ruby implementation files. You can find ourdoc.rb alongside these
# implementation files at:
#
# googleclient/sketchup/source/sketchup/ruby
#

require 'test/unit'

# TC_ComponentInstance contains unit tests for the ComponentInstance class.
#
# API Object::       ComponentInstance
# C++ File::         rcomponentinstance.cpp
# Parent Class::     Drawingelement
# Version::          SketchUp 6.0
#
# The ComponentInstance class is used to represent component instances of a
# component definition or components that have been dragged from the Component
# Browser and placed (thus, instanced) within the Model. Therefore, the
# ComponentInstance class contains a reference to a corresponding
# ComponentDefinition object and a Transformation object (which contains the
# location of the component in the Drawing Window).
#
#
class TC_ComponentInstance < Test::Unit::TestCase

  # Setup for test cases, if required.
  #
  def setup
    def UI::messagebox(params)
      puts 'TESTUP OVERRIDE: UI::messagebox > ' + params.to_s
    end
    model = Sketchup.active_model
    entities = model.entities
    # Clear the model.
    entities.clear!
    # Almost all of the tests assume at least 1 definition so build an empty
    # definition.
    definition = model.definitions.add("component")
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.name=
  # @file                rcomponentinstance.cpp
  #
  # The name method is used to set the name of this instance.
  #
  #
  # Args:
  # - name: name - the string name to set
  #
  # Returns:
  # - instance: the newly named ComponentInstance
  #

  # Test the example code that we have in the API documentation.
  def test_set_name_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     componentinstance.name = "Sang"
    end
  end

  # Test edgecases for values passed to this method.
  #def test_set_name_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_set_name_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_set_name_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # Test that the set name method works with strings.
  def test_set_name_works_with_string
    obj = Sketchup.active_model.entities.add_instance(Sketchup.active_model.definitions[0], Geom::Transformation.new([0,0,0]))
    messy_string = 'TestString!@#%^*&(*_[]}{:"":><.,?>/.\|'
    obj.name = messy_string
    result = obj.name
    expected = messy_string
    assert_equal(expected, result, 'Expected does not match result.')
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.glued_to
  # @file                rcomponentinstance.cpp
  #
  # The glued_to method is used to retrieve the entity that this instance
  # is glued to.
  #
  # Returns nil if it is not glued to anything.
  #
  #
  # Args:
  #
  # Returns:
  # - entity: the Entity object that the instance is glued
  # to (if successful)
  #

  # Test the example code that we have in the API documentation.
  def test_glued_to_api_example
    assert_nothing_raised do
     point = Geom::Point3d.new 10,20,30
     transform = Geom::Transformation.new point
     model = Sketchup.active_model
     entities = model.active_entities
     path = Sketchup.find_support_file "Bed.skp",
       "Components/Components Sampler/"
     definitions = model.definitions
     componentdefinition = definitions.load path
     instance = entities.add_instance componentdefinition, transform
     status = instance.glued_to
    end
  end

  # Test edgecases for values passed to this method.
  #def test_glued_to_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_glued_to_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_glued_to_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.definition=
  # @file                rcomponentinstance.cpp
  #
  # The definition= method is used to set the component definition for
  # this component.
  #
  # This method causes the instance to use a different definition, but it
  # will use the same transformation to position it in the Model.
  #
  #
  # Args:
  # - definition: A ComponentDefinition object to set.
  #
  # Returns:
  # - componentdefinition: the ComponentDefinition object
  # that was set if successful, false if unsuccessful
  #

  # Test the example code that we have in the API documentation.
  def test_set_definition_api_example
    assert_nothing_raised do
     # Need example ruby code here.
    end
  end

  # Test edgecases for values passed to this method.
  #def test_set_definition_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_set_definition_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_set_definition_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.glued_to=
  # @file                rcomponentinstance.cpp
  #
  # The glued_to= method glues this instance to a face.
  #
  # This method will raise an exception if the instance cannot be glued
  # to the given face. Instances cannot be glued if the definition of the
  # instance doesn't support gluing or if the alignment is wrong.
  #
  #
  # Args:
  #
  # Returns:
  # - face: the Face object where the component is glued if
  # successful
  #

  # Test the example code that we have in the API documentation.
  def test_set_glued_to_api_example
    assert_nothing_raised do
     depth = 100
     width = 100
     path=Sketchup.find_support_file "Bed.skp",
       "Components/Components Sampler/"
     model = Sketchup.active_model
     entities = model.active_entities
     pts = []
     pts[0] = [0, 0, 0]
     pts[1] = [width, 0, 0]
     pts[2] = [width, depth, 0]
     pts[3] = [0, depth, 0]
     # Add the face to the entities in the model
     face = entities.add_face pts
     point = Geom::Point3d.new 10,10,0
     transform = Geom::Transformation.new point
     definitions = model.definitions
     componentdefinition = definitions.load path
     instance = entities.add_instance componentdefinition, transform
     begin
       status = instance.glued_to = face
     rescue
       UI.messagebox $!.message
     end
     if (status)
       UI.messagebox status.to_s
     else
       UI.messagebox "Failure"
     end
    end
  end

  # Test edgecases for values passed to this method.
  #def test_set_glued_to_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_set_glued_to_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_set_glued_to_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.add_observer
  # @file                rcomponentinstance.cpp
  #
  # The add_observer method is used to add an observer to the current
  # object.
  #
  #
  # Args:
  # - observer: An observer.
  #
  # Returns:
  # - : true if successful, false if unsuccessful.
  #

  # Test the example code that we have in the API documentation.
  def test_add_observer_api_example
    observer = Object.new
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     status = componentinstance.add_observer observer
    end
  end
  # Test edgecases for values passed to this method.
  #def test_add_observer_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_add_observer_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_add_observer_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.locked=
  # @file                rcomponentinstance.cpp
  #
  # The locked= method is used to lock a component instance.
  #
  #
  # Args:
  #
  # Returns:
  # - status: true if the component instance is locked.
  # False if the instance is not locked.
  #

  # Test the example code that we have in the API documentation.
  def test_set_locked_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     status = componentinstance.locked = true
    end
  end

  # Test edgecases for values passed to this method.
  #def test_set_locked_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_set_locked_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_set_locked_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.transform!
  # @file                rcomponentinstance.cpp
  #
  # The transform! method is used to apply a transformation to a component
  # instance.
  #
  #
  # Args:
  # - transform: The transform object to apply to the component instance.
  #
  # Returns:
  # - status: true if successful, false if unsuccessful
  #

  # Test the example code that we have in the API documentation.
  def test_transform_inplace_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     new_transformation = Geom::Transformation.new([100,0,0])
     componentinstance.transform! new_transformation
    end
  end

  # Test edgecases for values passed to this method.
  #def test_transform_inplace_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_transform_inplace_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_transform_inplace_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.transformation=
  # @file                rcomponentinstance.cpp
  #
  # The transformation= method is used to set the transformation on this
  # instance.
  #
  #
  # Args:
  # - tranform: A Transformation object to apply.
  #
  # Returns:
  # - instance: the transformed ComponentInstance
  #

  # Test the example code that we have in the API documentation.
  def test_set_transformation_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     new_transformation = Geom::Transformation.new([100,0,0])
     componentinstance.transformation = new_transformation
    end
  end

  # Test edgecases for values passed to this method.
  #def test_set_transformation_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_set_transformation_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_set_transformation_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.name
  # @file                rcomponentinstance.cpp
  #
  # The name method is used to get the name of this instance.
  #
  #
  # Args:
  #
  # Returns:
  # - name: the string name of the ComponentInstance
  #

  # Test the example code that we have in the API documentation.
  def test_name_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     name = componentinstance.name
    end
  end

  # Test edgecases for values passed to this method.
  #def test_name_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_name_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_name_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.locked?
  # @file                rcomponentinstance.cpp
  #
  # The locked? method is used to determine if a component instance is
  # locked.
  #
  #
  # Args:
  #
  # Returns:
  # - status: true if the component instance is locked.
  # False if the instance is not locked.
  #

  # Test the example code that we have in the API documentation.
  def test_locked_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     status = componentinstance.locked?
    end
  end

  # Test edgecases for values passed to this method.
  #def test_locked_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_locked_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_locked_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.definition
  # @file                rcomponentinstance.cpp
  #
  # The definition method is used to retrieve the component definition for
  # this component instance.
  #
  #
  # Args:
  #
  # Returns:
  # - componentdefinition: a ComponentDefinition object if
  # successful
  #

  # Test the example code that we have in the API documentation.
  def test_definition_api_example
    assert_nothing_raised do
     point = Geom::Point3d.new 10,20,30
     transform = Geom::Transformation.new point
     model = Sketchup.active_model
     entities = model.active_entities
     path=Sketchup.find_support_file "Bed.skp",
       "Components/Components Sampler/"
    end
  end

  # Test edgecases for values passed to this method.
  #def test_definition_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_definition_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_definition_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.explode
  # @file                rcomponentinstance.cpp
  #
  # The explode method is used to explode the component instance into
  # separate entities.
  #
  #
  #
  # Args:
  #
  # Returns:
  # - entities: an Entities object if successful, false if
  # unsuccessful
  #

  # Test the example code that we have in the API documentation.
  def test_explode_api_example
    assert_nothing_raised do
     point = Geom::Point3d.new 10,20,30
     transform = Geom::Transformation.new point
     model = Sketchup.active_model
     entities = model.active_entities
     path = Sketchup.find_support_file "Bed.skp",
       "Components/Components Sampler/"
     definitions = model.definitions
     componentdefinition = definitions.load path
     instance = entities.add_instance componentdefinition, transform
    end
  end

  # Test edgecases for values passed to this method.
  #def test_explode_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_explode_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_explode_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.move!
  # @file                rcomponentinstance.cpp
  #
  # The move! method is the same as the transform! method, except that it
  # does not record the move as an undo operation.
  #
  # This method is useful for moving entities inside of an animation or
  # page transition.
  #
  #
  # Args:
  # - transform: The transform object to apply to the component instance.
  #
  # Returns:
  # - status: true if successful, false if unsuccessful
  #

  # Test the example code that we have in the API documentation.
  def test_move_inplace_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     new_transformation = Geom::Transformation.new([100,0,0])
     componentinstance.move! new_transformation
    end
  end

  # Test edgecases for values passed to this method.
  #def test_move_inplace_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_move_inplace_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_move_inplace_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.transformation
  # @file                rcomponentinstance.cpp
  #
  # The transformation method is used to retrieve the transformation of
  # this instance.
  #
  #
  # Args:
  #
  # Returns:
  # - transformation: the Transformation object if
  # successful
  #

  # Test the example code that we have in the API documentation.
  def test_transformation_api_example
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     t = componentinstance.transformation
    end
  end

  # Test edgecases for values passed to this method.
  #def test_transformation_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_transformation_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_transformation_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # Test that the entities method returns a Transformation object.
  def test_transformation_returns_transformation
    model = Sketchup.active_model
    transform = Geom::Transformation.new([0,0,0])
    obj = Sketchup.active_model.entities.add_instance(model.definitions[0],
                                                      transform)
    t = obj.transformation
    result = t.class
    expected = Geom::Transformation
    assert_equal(expected, result, 'Expected does not match result.')
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.remove_observer
  # @file                rcomponentinstance.cpp
  #
  # The remove_observer method is used to remove an observer from the
  # current object.
  #
  #
  # Args:
  # - observer: An observer.
  #
  # Returns:
  # - : true if successful, false if unsuccessful.
  #

  # Test the example code that we have in the API documentation.
  def test_remove_observer_api_example
    observer = Object.new
    assert_nothing_raised do
     entities = Sketchup.active_model.entities
     definition = Sketchup.active_model.definitions[0]
     transformation = Geom::Transformation.new([0,0,0])
     componentinstance = entities.add_instance(definition, transformation)
     status = componentinstance.remove_observer observer
    end
  end

  # Test edgecases for values passed to this method.
  #def test_remove_observer_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_remove_observer_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_remove_observer_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.make_unique
  # @file                rcomponentinstance.cpp
  #
  # The make_unique method is used to create a component definition for
  # this instance that is not used by any other instances.
  #
  #
  # Args:
  #
  # Returns:
  # - status: true if successful, false if unsuccessful
  #

  # Test the example code that we have in the API documentation.
  def test_make_unique_api_example
    assert_nothing_raised do
     point = Geom::Point3d.new 10,20,30
     transform = Geom::Transformation.new point
     model = Sketchup.active_model
     entities = model.active_entities

     path = Sketchup.find_support_file "Bed.skp",
       "Components/Components Sampler/"
     definitions = model.definitions
     componentdefinition = definitions.load path
     instance = entities.add_instance componentdefinition, transform
     # Returns unique component instance
     status = instance.make_unique
    end
  end

  # Test edgecases for values passed to this method.
  #def test_make_unique_edgecases
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_equal('expected', 'result',
  #               'Failed in test_make_unique_edgecases' )
  #end

  # Test what happens when bad arguments are passed (nil, too few, etc.)
  #def test_make_unique_bad_params
  #  raise('AUTOGENERATED STUB. Do manual review, then delete this warning.')
  #  assert_raise RuntimeError do
  #    # bad arguments here that should cause errors
  #  end
  #end


  # ----------------------------------------------------------------------------
  # Solid Tools tests
  # @par Ruby Method:    ComponentInstance.intersect
  # @file                rcomponentinstance.cpp

  # The intersect method is used to compute the boolean intersection of two
  # instances representing manifold solid volumes (this - arg).  If the
  # specified objects (this and arg) do not represent manifold volumes,
  # this method fails.

  # @version             SketchUp 8.0
  # @return              the resultant group if the two objects (this and arg)
  #                      represent manifold solids and the operation succeeds
  #                      otherwise Qnil is returned.
  def test_intersect
    model = Sketchup.active_model
    entities = model.entities
    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    #Test instance.intersect
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    point = Geom::Point3d.new 50,50,50
    t = Geom::Transformation.new point
    golden = entities.add_group

    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [50, 0, 0]
    pts1[2] = [50, 50, 0]
    pts1[3] = [0, 50, 0]

    # Add the face to the entities in the group
    face = golden.entities.add_face pts1
    status = face.pushpull -50, true
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    intersection = instance1.intersect(instance2)
    assert_equal(true, golden.equals?(intersection),
                 'instance.intersect failed' )
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.union
  # @file                rcomponentinstance.cpp

  # The union method is used to compute the boolean union of the two instances
  # representing manifold solid volumes (this | arg).  If the specified
  # objects (this and arg) do not represent manifold volumes, this method fails.

  # @version             SketchUp 8.0
  # @return              the resultant group if the two objects (this and arg)
  #                      represent manifold solids and the operation succeeds
  #                      otherwise Qnil is returned
  def test_union
    model = Sketchup.active_model
    entities = model.entities
    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    point = Geom::Point3d.new 50,50,0
    t = Geom::Transformation.new point

    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [100, 0, 0]
    pts1[2] = [100, 50, 0]
    pts1[3] = [150, 50, 0]
    pts1[4] = [150, 150, 0]
    pts1[5] = [50, 150, 0]
    pts1[6] = [50, 100, 0]
    pts1[7] = [0, 100, 0]

    # Add the face to the entities in the group
    golden = entities.add_group
    face = golden.entities.add_face pts1
    status = face.pushpull -100, true

    #Test instance.union
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    union = instance1.union(instance2)
    assert_equal(true, golden.equals?(union), 'instance.union failed' )
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.subtract
  # @file                rcomponentinstance.cpp

  # The subtract method is used to compute the boolean difference of the two
  # instances representing manifold solid volumes (this - arg).  If the
  # specified objects (this and arg) do not represent manifold volumes,
  # this method fails.

  # @version             SketchUp 8.0
  # @return              the resultant group if the two objects (this and arg)
  #                      represent manifold solids and the operation succeeds
  #                      otherwise nil is returned.
  def test_subtract
    model = Sketchup.active_model
    entities = model.entities

    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    point = Geom::Point3d.new 50,50,0
    t = Geom::Transformation.new point

    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [100, 0, 0]
    pts1[2] = [100, 50, 0]
    pts1[3] = [50, 50, 0]
    pts1[4] = [50, 100, 0]
    pts1[5] = [0, 100, 0]

    # Add the face to the entities in the group
    golden = entities.add_group
    face = golden.entities.add_face pts1
    status = face.pushpull -100, true
    #Test instance.subtract
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    difference = instance2.subtract(instance1)
    assert_equal(true, golden.equals?(difference), 'instance.subtract failed' )
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.trim
  # @file                rcomponentinstance.cpp

  # The trim method is used to compute the (non-destructive) boolean difference
  # of the two instances representing manifold solid volumes (this - arg).  If
  # the specified objects (this and arg) do not represent manifold volumes,
  # this method fails.

  # @version             SketchUp 8.0
  # @return              the resultant group if the two objects (this and arg)
  #                      represent manifold solids and the operation succeeds
  #                      otherwise nil is returned.
  def test_trim
    model = Sketchup.active_model
    entities = model.entities

    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    point = Geom::Point3d.new 50,50,0
    t = Geom::Transformation.new point

    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [100, 0, 0]
    pts1[2] = [100, 50, 0]
    pts1[3] = [50, 50, 0]
    pts1[4] = [50, 100, 0]
    pts1[5] = [0, 100, 0]

    # Add the face to the entities in the group
    golden = entities.add_group
    face = golden.entities.add_face pts1
    status = face.pushpull -100, true
    #Test instance.trim
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    difference = instance2.trim(instance1)
    assert_equal(true, golden.equals?(difference), 'instance.trim failed' )
  end

  # ----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.split
  # @file                rcomponentinstance.cpp

  # The split method is used to compute the boolean split (map overlay)of the
  # two instances representing manifold solid volumes (this - arg).
  # If the specified objects (this and arg) do not represent manifold volumes,
  # this method fails.

  # @version             SketchUp 8.0
  # @return              a vector (array) of the three resultant groups if the
  #                      two objects (this and arg) represent manifold solids
  #                      and the operation succeeds otherwise nil is returned.
  #
  #                      The 3 groups are as follows:
  #                        The intersection of volume 1 & volume 2
  #                        The difference of volume 1 - volume 2
  #                        The reverse difference of volume 2 - volume 1
  def test_split
    model = Sketchup.active_model
    entities = model.entities
    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    point = Geom::Point3d.new 50,50,0
    t = Geom::Transformation.new point

    golden1 = entities.add_group
    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [100, 0, 0]
    pts1[2] = [100, 50, 0]
    pts1[3] = [50, 50, 0]
    pts1[4] = [50, 100, 0]
    pts1[5] = [0, 100, 0]
    # Add the face to the entities in the group
    face = golden1.entities.add_face pts1
    status = face.pushpull -100, true

    golden2 = entities.add_group
    pts2 = []
    pts2[0] = [50, 0, 0]
    pts2[1] = [100, 0, 0]
    pts2[2] = [100, 100, 0]
    pts2[3] = [0, 100, 0]
    pts2[4] = [0, 50, 0]
    pts2[5] = [50, 50, 0]
    # Add the face to the entities in the group
    face = golden2.entities.add_face pts2
    status = face.pushpull -100, true

    golden3 = entities.add_group
    pts3 = []
    pts3[0] = [0, 0, 0]
    pts3[1] = [50, 0, 0]
    pts3[2] = [50, 50, 0]
    pts3[3] = [0, 50, 0]

    # Add the face to the entities in the group
    face = golden3.entities.add_face pts3
    status = face.pushpull -100, true

    #Test instance.split
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    split_groups = instance1.split(instance2)
    # This "if" logic is necessary because the order of the differences is
    # random...
    if(golden1.equals?(split_groups[0]))
      #if golden1 == split_group[0], then golden2 must == split_group[1].
      assert_equal(true, golden2.equals?(split_groups[1]),
                   'group.split(2) failed' )
    else
      #if golden1 != split_group[0], then golden1 must == split_group[1] and
      #   golden2 must == split_group[0].
      assert_equal(true, golden1.equals?(split_groups[1]),
                   'group.split(1) failed' )
      assert_equal(true, golden2.equals?(split_groups[0]),
                   'group.split(2) failed' )
    end
    assert_equal(true, golden3.equals?(split_groups[2]),
                 'group.split(3) failed' )
  end

  #----------------------------------------------------------------------------
  # @par Ruby Method:    ComponentInstance.outer_shell
  # @file                rcomponentinstance.cpp

  # The outer_shell method is used to compute the outer shell of the two
  # instances representing manifold solid volumes (this || arg). If the
  # specified objects (this and arg) do not represent manifold volumes,
  # this method fails.

  # @version             SketchUp 8.0
  # @return              the resultant group if the two objects (this and arg)
  #                      represent manifold solids and the operation succeeds
  #                      otherwise nil is returned.
 def test_outer_shell
    model = Sketchup.active_model
    entities = model.entities
    pts = []
    pts[0] = [0, 0, 0]
    pts[1] = [100, 0, 0]
    pts[2] = [100, 100, 0]
    pts[3] = [0, 100, 0]

    point = Geom::Point3d.new 50,50,0
    t = Geom::Transformation.new point

    golden = entities.add_group
    pts1 = []
    pts1[0] = [0, 0, 0]
    pts1[1] = [100, 0, 0]
    pts1[2] = [100, 50, 0]
    pts1[3] = [150, 50, 0]
    pts1[4] = [150, 150, 0]
    pts1[5] = [50, 150, 0]
    pts1[6] = [50, 100, 0]
    pts1[7] = [0, 100, 0]

    # Add the face to the entities in the group
    face = golden.entities.add_face pts1
    status = face.pushpull -100, true

    #Test instance.outer_shell
    definition = model.definitions.add("component")
    # Add the face to the entities in the group
    face = definition.entities.add_face pts
    status = face.pushpull -100, true
    origin = Geom::Point3d.new 0, 0, 0
    transform = Geom::Transformation.new origin
    instance1 = entities.add_instance definition, transform
    instance2 = instance1.copy
    instance2.move! t
    outer_shell = instance1.outer_shell(instance2)
    assert_equal(true, golden.equals?(outer_shell),
                 'instance.outer_shell failed' )
  end
end

